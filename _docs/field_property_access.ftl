<div class="bs-docs-section">
<h1 id="field_and_property_access">Field and property access</h1>
<p>Field and Property access are the two ways in which a field/property is
managed/intercepted. What this means is that the ORM needs to intercept the reading or
writing of either Fields or Properties.
</p><p>
An ORM does this interception to provide lazy loading and dirty checking functionality and
an ORM achieves this using either Enhancement or Subclass generation (Subclass
generation is also referred to as "Proxy classes").
</p><p>
To explain Field Access and Property Access I'll use an example focusing on a single field
(in this case "firstName") and how Property Access and Field Acccess works in Ebean.

```java
...
@Entity
public class Person {

  @Id
  int id;
  String firstName;
  String lastName;

  ...

  // An extra method... NOT a getter...
  // here to highlight the difference between
  // Field and Property Access
  public String getFullName() {
    return firstName + " " + lastName;
  }

  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  // getters and setters for id and lastName not shown...
  ...
```

<#-------------------------------------------------------------------------------------------------->
<h2 id="property_access">Property access</h2>
<p>By "Property" we really mean a Java Bean Property. In the case of the "firstName"
property this means the related getter and setter methods of getFirstName() and
setFirstName(...). Refer to the Java Bean naming convention for clarification.
</p><p>
With Property Access you MUST have a setter and a getter.
</p><p>
With Property Access ONLY the getter and setter are intercepted. If you use the field in
other methods then access to that field is not intercepted/managed (See the
getFullName() method as an example).

<h4>Property Access with Ebean</h4>

```java
  ...
  public String getFullName() {
    // not getter or setter so NOT intercepted...
    return firstName+" "+ lastName;
  }
  public String getFirstName() {
    _ebean_intercept.preGetter("firstName");
    return firstName;
  }
  public void setFirstName(String newValue) {
    _ebean_intercept.preSetter("firstName", newValue, getFirstName());
    this.firstName = newValue;
  }
```

<p>
This is an example of how Ebean modifies/generates code to support "property access"
</p><p>
The modified/generated class now has a _ebean_intercept field.
</p><p>
In calling getName() the preGetter() method is called on the intercept field and this will invoke lazy loading if required.
</p><p>
In calling setName() getName() is called which in turn can invoke lazy loading. The
getName() returns the "Old Value" / "Previous Value" of the name. The preSetter() method
is called on the intercept and will maintain the "Dirty Checking" information.
</p><p>
If your entity beans just have getter and setter methods they are well suited to property
access. From a design perspective they may also be called "Anemic" in the sense that
they don't have any logic and can almost be viewed as pure data.

<#-------------------------------------------------------------------------------------------------->
<h2 id="field_access">Field access</h2>
<p>Field access in general is implemented via bytecode Enhancement (Also refered to as Weaving and Transformation).
/p><p>
The class bytes are modified replacing the GETFIELD and PUTFIELD bytecode calls to
"persistent fields" with method calls.
</p><p>
With Ebean Field access looks something like this... (note: other ORMs could generate
quite different code)

```java
  public String getFullName() {
    // GETFIELD firstName replaced...
    return _ebean_getFirstName()+" "+_ebean_getLastName();
  }
  public String getFirstName() {
    // GETFIELD firstName replaced
    return _ebean_getFirstName();
  }
  public void setFirstName(String newValue) {
    // PUTFIELD firstName replaced
    _ebean_setFirstName(newValue);
  }

  // new method generated by Ebean
  // used to replace GETFIELD firstName
  String _ebean_getFirstName() {
    _ebean_intercept.preGetter("firstName");
    return this.firstName;
  }

  // new method generated by Ebean
  // used to replace PUTFIELD firstName
  void _ebean_setFirstName(String newValue) {
    String currentValue = _ebean_getFirstName();
    _ebean_intercept.preSetter("firstName", newValue, currentValue);
    this.firstName = newValue;
  }
```
</p><p>
With Field access it actually doesn't matter where the field is used the GETFIELD and
PUTFIELD byte code instructions are replaced. It is important to note that in the example
above the getFullName() method is also modified to support the interception/mangement
by the ORM.
</p><p>
Unlike property access field access does not require the getter or setter to even exist –
they can be removed if you want.
Essentially with Field access you can write whatever code you like (within reason) and it
will behave as expected (ORM interception occuring as and how you would expect).
</p>


<#-------------------------------------------------------------------------------------------------->
<h2 id="field_vs_property_access">Ebean – Field vs Property access</h2>

<p>...(under construction)... this documentation needs reworked due to ebean no longer supporting subclassing</p>

<p>
With JPA you choose between field or property access on a per field / property basis. If
you put the annotation on the field this implies that you want field access and if you put
the annotation on the associated getter method of the property then you should get
property access.
</p><p>
Ebean does not work this way!!!
</p>

<p>Ebean has not followed the JPA approach. With Ebean you get Field Access when you
use Enhancement and you get Property Access when you use Subclassing.
</p><p>
The reason for this comes down to...
<ul>
  <li>Keeping things simple</li>
  <li>Field Access is the preferred approach</li>
  <li>Subclassing approach introduces security / visibility issues for Field Access</li>
</ul>
</p><p>
There are a few downsides to Field Access.
  <ul>
    <li>Serialization: Your entity beans now include and depend on Ebean objects. Where you
deserialize them you will need some Ebean classes in you class path.</li>
    <li>Using javaagent or one of the build time enhancement methods can an be a pain. Ebean
has tried to make this as simple and robust as possible.</li>
    <li>Java Web Start does not support javaagent. However, you can enhance the
classes at build time.</li>
  </ul>
</p>

<h4>Ebean interception notes</h4>
<p><b>Id Interception</b></p>
<p>Id fields/properties are not intercepted ever (either for reading or writing). That is, getting
or setting an ID will never invoke lazy loading or cause the entity to be marked as dirty.</p>

<p><b>OneToMany and ManyToMany Interception</b></p>
<p>
The List Set and Map persistent properties are not intercepted when they are being set.
That is, setting a associated many property does not invoke lazy loading or mark the entity
as dirty.
</p><p>
When you get a entity back from a query every associated many property (List Set or
Map) will have a 'proxy' in place. It is not until you invoke a method on the List Set or Map
proxy that lazy loading of that proxy will occur.
</p><p>
A reference object (obtained by Ebean.getReference()) will lazy load the entity bean if a
List Set or Map associated many property is read (via getter etc).

<p><b>toString() interception</b></p>
<p>
No interception is invoked by a toString() method. The reason for this decision is that
toString() is often invoked by an IDE while running a debugger – in the past this has lead
to confusion to have lazy loading being invoked accidentally in this fashion.
</p>

<p><b>equals() and hashCode() generation</b></p>
<p>
If your entity bean does not have a equals() or hashCode() method then one will be
generated for you based on the identity property using the "" technique.
The generated equals() or hashCode() methods do not invoke lazy loading.
</p>
<p><b>@Transient on methods</b></p>
<p>If you are using Ebean enhancement (Field Access) then you can put the @Transient
annotation on a method and it is NOT intercepted. Specifically the method is left exactly
as it is (rather than having the GETFIELD PUTFIELD byte codes replaced with
intercepted method calls).
</p><p>
This is an Ebean extension to the JPA spec. This enables you to write a method on an
entity bean that you know will not have its field access intercepted.
</p>



<p>Q: JPA supports the mixing of Field and Property access on the same entity bean. Will
Ebean look to support this?
</p><p>
A: No. If you can do field access then you should. On the web there is mention of benefits
to using Property access such as performance and type conversion benefits. None of
these apply to Ebean.
</p><p>
Q: How does the enhancement work for with Groovy or Scala entity beans?
</p><p>
A: You can use Ebean enhancement on Groovy or Scala beans. Note this includes
support for Scala's properties (which don't follow the Java Bean Spec getter setter method
naming conventions). Ebean can tell if it is a Groovy bean or Scala bean and take that into
account as needed.
</p>
</div>
