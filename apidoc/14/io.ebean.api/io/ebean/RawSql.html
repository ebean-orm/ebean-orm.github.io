<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (21) on Tue May 14 21:29:28 NZST 2024 -->
<title>RawSql (ebean api 14.3.0 API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2024-05-14">
<meta name="description" content="declaration: module: io.ebean.api, package: io.ebean, interface: RawSql">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/RawSql.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Nested</li>
<li>Field</li>
<li>Constr</li>
<li>Method</li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li>Constr</li>
<li>Method</li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li>Method</li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li>Method</li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="module-label-in-type">Module</span>&nbsp;<a href="../../module-summary.html">io.ebean.api</a></div>
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">io.ebean</a></div>
<h1 title="Interface RawSql" class="title">Interface RawSql</h1>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public interface </span><span class="element-name type-name-label">RawSql</span></div>
<div class="block">Used to build object graphs based on a raw SQL statement (rather than
 generated by Ebean).
 <p>
 If you don't want to build object graphs you can use <a href="SqlQuery.html" title="interface in io.ebean"><code>SqlQuery</code></a> instead
 which returns <a href="SqlRow.html" title="interface in io.ebean"><code>SqlRow</code></a> objects rather than entity beans.
 <p>
 <b>Unparsed RawSql:</b>
 <p>
 When RawSql is created via <a href="RawSqlBuilder.html#unparsed(java.lang.String)"><code>RawSqlBuilder.unparsed(String)</code></a> then Ebean can not
 modify the SQL at all. It can't add any extra expressions into the SQL.
 <p>
 <b>Parsed RawSql:</b>
 <p>
 When RawSql is created via <a href="RawSqlBuilder.html#parse(java.lang.String)"><code>RawSqlBuilder.parse(String)</code></a> then Ebean will parse the
 SQL and find places in the SQL where it can add extra where expressions, add
 extra having expressions or replace the order by clause. If you want to
 explicitly tell Ebean where these insertion points are you can place special
 strings into your SQL (<code>${where}</code> or <code>${andWhere}</code> and <code>${having}</code> or
 <code>${andHaving})</code>.
 <p>
 If the SQL already includes a WHERE clause put in <code>${andWhere}</code> in the location
 you want Ebean to add any extra where expressions. If the SQL doesn't have a
 WHERE clause put <code>${where}</code> in instead. Similarly you can put in <code>${having}</code> or
 <code>${andHaving}</code> where you want Ebean put add extra having expressions.
 <p>
 <b>Aggregates:</b>
 <p>
 Often RawSql will be used with Aggregate functions (sum, avg, max etc). The
 follow example shows an example based on Total Order Amount -
 sum(d.order_qty*d.unit_price).
 </p>
 <p>
 We can use a OrderAggregate bean that has a &#064;Sql to indicate it is based
 on RawSql and not based on a real DB Table or DB View. It has some properties
 to hold the values for the aggregate functions (sum etc) and a &#064;OneToOne
 to Order.
 <p>
 <h3 id="example-orderaggregate-heading">Example OrderAggregate</h3>
 <pre><code>
  ...
   // @Sql indicates to that this bean
   // is based on RawSql rather than a table

   @Entity
   @Sql
   public class OrderAggregate {

    @OneToOne
    Order order;

    Double totalAmount;

    Double totalItems;

    // getters and setters
    ...
   }
 </code></pre>

 <h3 id="example-1--heading">Example 1:</h3>

 <pre><code>

   String sql = " select order_id, o.status, c.id, c.name, sum(l.order_qty*l.unit_price) as totalAmount"
     + " from order o"
     + " join customer c on c.id = o.customer_id "
     + " join order_line l on l.order_id = o.id " + " group by order_id, o.status ";

   RawSql rawSql = RawSqlBuilder.parse(sql)
     // map the sql result columns to bean properties
     .columnMapping("order_id", "order.id")
     .columnMapping("o.status", "order.status")
     .columnMapping("c.id", "order.customer.id")
     .columnMapping("c.name", "order.customer.name")
     // we don't need to map this one due to the sql column alias
     // .columnMapping("sum(d.order_qty*d.unit_price)", "totalAmount")
     .create();

   List&lt;OrderAggregate&gt; list = DB.find(OrderAggregate.class)
       .setRawSql(rawSql)
       .where().gt("order.id", 0)
       .having().gt("totalAmount", 20)
       .findList();


 </code></pre>

 <h3 id="example-2--heading">Example 2:</h3>
 <p>
 The following example uses a FetchConfig().query() so that after the initial
 RawSql query is executed Ebean executes a secondary query to fetch the
 associated order status, orderDate along with the customer name.

 <pre><code>

  String sql = " select order_id, 'ignoreMe', sum(l.order_qty*l.unit_price) as totalAmount "
     + " from order_line l"
     + " group by order_id ";

   RawSql rawSql = RawSqlBuilder.parse(sql)
     .columnMapping("order_id", "order.id")
     .columnMappingIgnore("'ignoreMe'")
     .create();

   List&lt;OrderAggregate&gt; orders = DB.find(OrderAggregate.class)
     .setRawSql(rawSql)
     .fetch("order", "status,orderDate", FetchConfig.ofQuery())
     .fetch("order.customer", "name")
     .where().gt("order.id", 0)
     .having().gt("totalAmount", 20)
     .order().desc("totalAmount")
     .setMaxRows(10)
     .findList();

 </code></pre>
 <h3 id="example-3-tablealiasmapping-heading">Example 3: tableAliasMapping</h3>
 <p>
 Instead of mapping each column you can map each table alias to a path using tableAliasMapping().
 <pre><code>

   String rs = "select o.id, o.status, c.id, c.name, "+
               " l.id, l.order_qty, p.id, p.name " +
               "from orders o join o_customer c on c.id = o.customer_id " +
               "join order_line l on l.order_id = o.id  " +
               "join product p on p.id = l.product_id  " +
               "where o.id &lt;= :maxOrderId  and p.id = :productId "+
               "order by o.id, l.id asc";

  RawSql rawSql = RawSqlBuilder.parse(rs)
       .tableAliasMapping("c", "customer")
       .tableAliasMapping("l", "lines")
       .tableAliasMapping("p", "lines.product")
       .create();

  List&lt;Order&gt; ordersFromRaw = DB.find(Order.class)
       .setRawSql(rawSql)
       .setParameter("maxOrderId", 2)
       .setParameter("productId", 1)
       .findList();

 </code></pre>
 <p>
 Note that lazy loading also works with object graphs built with RawSql.</div>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small>Copyright &#169; 2024. All rights reserved.</small></p>
</footer>
</div>
</div>
</body>
</html>
