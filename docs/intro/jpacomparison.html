<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta id="layout-head" />
    <title>avaje ebean</title>
    <link rel="shortcut icon" href="/images/favicon.ico" >
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/pygments.css" rel="stylesheet" type="text/css" />
    <link href="/css/site.css" rel="stylesheet">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
  <body>
  <div id="wrap">    
    <div id="header">    
    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Ebean ORM</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav pull-right">
            <li ><a href="/"><span class="glyphicon glyphicon-home"></span>  Home</a></li>
            <li ><a href="/quickstart">Quick Start</a></li>
            <li ><a href="/support">Support</a></li>
            <li class="active"><a href="/documentation">Documentation</a></li>
            <li ><a href="/releases">Releases</a></li>
            <li ><a href="https://github.com/ebean-orm/avaje-ebeanorm"> <i class="fa fa-github"></i> Github</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

  </div>
  <div id="main">    
<div class="jumbotron mini">
    <div class="container">
      <h1><a href="/documentation">Documentation</a> / Introduction  </h1>
    </div>
  </div>

  <div class="container">
    <div class="row">

      <div class="page-content col-lg-9">
<h1>Comparison to JPA</h1>


<h2>Dirty state on the bean</h2>
<p>
  The core architectural difference is that Ebean stores the 'dirty state' on
  the bean itself. All knowledge required to persist a bean is on the bean itself and beans
  are explicited saved or deleted.
</p>
<p>
  With Hibernate the Session holds the 'original state' and this along with the bean are used to
  persist the beans. Beans need to be 'attached' to the Session in order to persist them.
</p>
<p class="bs-callout bs-callout-info">
    This architectural difference means that there is no EntityManager with the associated bean lifecycle
    and flush mechanism. This is what makes Ebean easier to use and understand.
</p>

<h3>Lifecycle - EntityManager</h3>
<p>
  With Hibernate, JPA and JDO the beans have a lifecycle where the beans are attached/detached/merged/flushed
  using a JPA EntityManager (and similarly with JDO PersistenceManager).
  Developers need to be aware of this lifecycle and now not only have to manage
  the DB Transaction demarcation but they additionally have to manage the JPA EntityManager (or JDO PersistenceManager).
  Some containers and frameworks provide assistence to developers to help manage the EntityManager like 'Transaction scoped Persistence Context'
  but architecturally with JPA and JDO there are 2 things demarcate/scope. When developers want to use
  multiple transactions with the same persistence context and have to deal with the failure cases they now
  need to have a good understanding of the underlying EntityManager/Session and throw it away or ponder what
  is needed to make the EntityManager/Session usable.
</p>
<p class="bs-callout bs-callout-info">
  With Ebean you only need to demarcate/scope the transaction - no EntityManager/Session to manage.
</p>

<h3>Explicit save rather than flush</h3>
<p>
  With Ebean the developer explicitly controls which beans are persisted. With JPA/JDO you don't have that
    control and instead use flush() and the dirty beans that are 'attached' to the Session/EntityManager are persisted.
    When the EntityManager is used by various blocks of code it is not always obvious what beans will be included in the flush() - an
    attached bean might have subtly been made dirty or an additional dirty bean attached. This lack of explicit
    control can make these issues occur and are not always easy to resolve.
</p>
<p class="bs-callout bs-callout-info">
  With Ebean the developer explicitly controls which beans are persisted.
</p>

<h2>Partial Objects</h2>
<p>
  Back in 1995 I worked for Oracle Tech Support and was a trained Oracle DBA. If your query (or part of
  the query execution) could be resolved by just hitting 'index blocks' and didn't have to read 'data blocks'
  that was great for performance. Any decent ORM query language almost 20 years later would surely support
  the ability to only select the properties you need in order to support this fundamental performance
  optimisation?
</p>
<p class="bs-callout bs-callout-info">
  Ebean makes partial object queries easy.
</p>
<p>
  JPA has added 'FetchGroups' to support Partial Objects but to me it is not easy to use and should instead
  have become part of the query language.
</p>
<p>
  It is unsurprising that DBA's and SQL orientated developers have looked at the SQL that their ORM
  has generated and had a feeling of disappointment and maybe even dispair. I suspect there wasn't
  a DBA in the room when JPQL was designed or perhaps they didn't get a strong vote.
</p>
<p>
  Ebean's query language has be designed from the perspective of making is easy to specify the parts
    of the object graph you wish to fetch (Partial Objects). Additionally Ebean has made it easier
    to use by automatically determining the joins that are required to support the select, where and
    order by.
</p>

<h4>Autofetch - Query optimisation</h4>
<p>
  The extension to supporting 'Partial Objects' is to provide a mechanism that profiles what parts of
    the object graph are used for any given query. This profiling information can then be used to
    actively tune the query or provide performance improvement suggestions.
</p>
      </div>

      <div class="col-lg-3 hidden-md hidden-sm">
          <div class="side-bar">
              <h5>
                <a href="/documentation">DOCUMENTATION</a>
              </h5>
              <ul class="side-nav">
      <li >
          <i class="fa fa-chevron-right"></i> <a href="/docs/intro/about">Introduction</a>
      </li>
      <li >
          <i class="fa fa-chevron-right"></i> <a href="/docs/intro/programmingstyles">Programming styles</a>
      </li>
      <li class="active">
          <i class="fa fa-chevron-right"></i> <a href="/docs/intro/jpacomparison">Comparison to JPA</a>
      </li>
              </ul>
          </div>
      </div>

    </div> <!-- /.row -->
  </div>  <!-- /.container -->    
  </div>
</div>

<footer id="footer">
 <div class="doc-footer">
  <ul class="doc-footer-links">
    <li><a href="/">Ebean ORM</a></li>
    <li> | </li>
    <li><a href="/metrics/index">Metrics</a></li>
    <li> | </li>
    <li><a href="/websitegenerator/index">Website Generator</a></li>
    <li> | </li>
    <li><a href="/jetty/index">Jetty Runnable War</a></li>
  </ul>
 </div>
</footer>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  </body>
</html>
