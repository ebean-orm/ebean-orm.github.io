
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta id="layout-head" />
    <title>avaje ebean</title>
    <link rel="shortcut icon" href="/images/favicon.ico" >
    <!--<link href="/css/bootstrap.min.css" rel="stylesheet">-->
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="/css/site.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">
      <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
  <body>
  <div id="wrap">
    <div id="header">
    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">Ebean ORM</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav pull-right">
            <li ><a href="/"><span class="glyphicon glyphicon-home"></span>  Home</a></li>
            <li ><a href="/videos">Videos</a></li>
            <li ><a href="/quickstart">Quick Start</a></li>
            <li ><a href="/support">Support</a></li>
            <li class="active"><a href="/docs">Docs</a></li>
            <li ><a target="_blank" href="/apidocs">ApiDocs</a></li>
            <li ><a href="/releases">Releases</a></li>
            <li ><a target="_blank" href="https://github.com/ebean-orm/avaje-ebeanorm"> <i class="fa fa-github"></i> Github</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

  </div>
  <div id="main" data-offset="60">
<div class="jumbotron mini">
  <div class="container">
    <h1><a href="/docs">Documentation</a> / Architecture </h1>
  </div>
</div>

<div class="container doc-index bs-docs-container">

  <div class="row">

    <div class="col-md-9" role="main">

      <div class="bs-docs-section">

  <h1 id="persistence-context">Persistence Context</h1>

  <h2 id="definition">Definition</h2>

  <p>Although Ebean doesn't have a JPA Entity Manager it does have a Persistence context. In
    fact, you could go as far to say that any ORM worth using needs a persistence context in order
    to build consistent object graphs.</p>

  <h4>JPA v1.0 specification - section 5.1</h4>
  <blockquote>"A persistence context is a set of managed entity instances in which for any persistent entity identity
    there is a unique entity instance. Within the persistence context, the entity instances and their
    lifecycle are managed by the entity manager."
  </blockquote>

  <p>Ebean has a Persistence Context to ensure unique entity instances but Ebean has a
    different approach to lifecycle management compared to JPA.</p>

  <p>That is, Ebean has a persistence context to ensure <code>unique entity instance.</code>
    but has a different approach to the lifecycle management
    compared with JPA. Ebean has no entity manager and no persist/merge/flush lifecycle
    methods and the persistence context is not involved in persisting.</p>


  <h2>Unique Entity Instances</h2>

  <p>Ebean uses the Persistence context for queries and lazy loading (when it is building object
    graphs). The purpose of this is to ensure that <code>consistent object graphs</code> are constructed
    (1 unique instance per identity).</p>
  <blockquote>
    Ensuring unique instances equates to building a consistent object graph
  </blockquote>

  <p>For example, in fetching a list of orders and their customers … the persistence context
    ensures that you only get 1 customer instance for it's given id (e.g. you are NOT allowed to
    have 2 or more instances of "customer id=7".</p>

  <p>You could even say that any ORM worth using needs a persistence context when it builds
    object graphs from relational result sets due to the nature of relational result sets.</p>

  <p>For example, if you didn't have a persistence context and did allow 2 or more instances of
    "customer 7" … and modified one instance but not the other … things get very ugly. The
    "persistence context" ensures the user/application code works with unique entity instances.</p>

  <h2>Persisting</h2>

  <p>Ebean has a different approach to lifecycle management. The core difference is that with
    Ebean each bean itself has it's own dirty checking (detects when it has been modified and
    holds it's old/original values for optimistic concurrency checking).
  </p>

  <p>
    This means that for Ebean is does not need or use the persistence context when persisting beans.
  </p>
  <blockquote>
    Ebean's persistence context is not involved in persisting.
  </blockquote>

  <p>With JPA implementations generally the dirty checking is performed by the entity manager.
    The entity manager generally holds the old/original values for optimistic concurrency
    checking and the beans need to be 'attached' to an entity manager to be 'flushed' (as an
    insert/update/delete). [Note: JDO based JPA implementations do this a bit differently].
  </p>

  <p>
    Pro's for Ebean's approach:
  </p>
  <ul>
    <li>No need to manage Entity Manager's</li>
    <li>save/delete simpler that attached/detached beans with persist/merge/flush etc</li>
  </ul>

  <p>
    Con's for Ebean's approach:
  </p>
  <ul>
    <li>Ebean makes an assumption that scalar types are immutable. Most scalar types (String, Integer, Double, Float,
      BigDecimal etc) are immutable, however, some such as java.util.Date are not. What this means is that with Ebean if
      you mutate a java.util.Date Ebean will NOT detect the change – instead you have to set a different java.util.Date
      instance.
    </li>
  </ul>
  </p>

  <h2>Scopes</h2>

  <p>
    Ebean has 3 scopes for the the persistence context - <code>Transaction scope</code>, <code>Query scope</code>
    and <code>Per Object Graph scope</code>.
  </p>

  <h2>Transaction scope</h2>

  <p>With Ebean the persistence context is by default transaction scoped. This means that when you begin
    a new transaction (implicitly or explicitly) Ebean will start a new persistence context.</p>

  <p>The persistence context lives beyond the end of a transaction. This enables any lazy
    loading occurring after the transaction ends to use the same persistence context that the instance
    was created with.
  </p>

  <p>
    This means, a persistence context
  <ul>
    <li>Starts when a transaction starts</li>
    <li>Is used during the transactions scope to build all object graphs (queries)</li>
    <li>Lives beyond the end of a transaction so that all lazy loading occurring on that object graph also uses the same
      persistence context
    </li>
  </ul>
  </p>

  <h3>Transaction scoped persistence context as a "first level cache"</h3>

  <p>The persistence context is sometimes described as the "first level cache" or L1 cache. I have also seen
    it described as the "transactional cache" in that it is most frequently scoped to a transaction.</p>

  <div class="syntax java"><div class="highlight"><pre>  <span class="c1">// a new persistence context started with the transaction</span>
  <span class="n">Ebean</span><span class="o">.</span><span class="na">beginTransaction</span><span class="o">();</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="c1">// find &quot;order 72&quot; results in that instance being put</span>
    <span class="c1">// into the persistence context</span>
    <span class="n">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">Ebean</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">72</span><span class="o">);</span>

    <span class="c1">// finds an existing &quot;order 72&quot; in the persistence context</span>
    <span class="c1">// ... so just returns that instance</span>
    <span class="n">Order</span> <span class="n">o2</span> <span class="o">=</span> <span class="n">Ebean</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">72</span><span class="o">);</span>
    <span class="n">Order</span> <span class="n">o3</span> <span class="o">=</span> <span class="n">Ebean</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="n">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">72</span><span class="o">);</span>

    <span class="c1">// all the same instance</span>
    <span class="n">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">order</span> <span class="o">==</span> <span class="n">o2</span><span class="o">);</span>
    <span class="n">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">order</span> <span class="o">==</span> <span class="n">o3</span><span class="o">);</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">Ebean</span><span class="o">.</span><span class="na">endTransaction</span><span class="o">();</span>
  <span class="o">}</span>
  
</pre></div>
</div>
  <p>
    The code above shows that there is only 1 instance of "Order 72". As we try to fetch it
    again (during the scope of a single persistence context) we end up getting back the same
    instance.</p>

  <p>
    However, typically you don't write code that fetches the same Order multiple times in a
    single transaction. The code above is not something you would typically write.</p>

  <p>
    A more realistic example would be when the persistence context is used:

    <div class="syntax java"><div class="highlight"><pre>    <span class="c1">// a new persistence context started with the transaction</span>
    <span class="n">Ebean</span><span class="o">.</span><span class="na">beginTransaction</span><span class="o">();</span>

    <span class="k">try</span> <span class="o">{</span>
      <span class="c1">// find &quot;customer 1&quot; results in this instance being</span>
      <span class="c1">// put into the persistence context</span>
      <span class="n">Customer</span> <span class="n">customer</span> <span class="o">=</span> <span class="n">Ebean</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">Customer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>

      <span class="c1">// for this example … &quot;customer 1&quot; placed &quot;order 72&quot;</span>
      <span class="c1">// when &quot;order 72&quot; is fetched/built it has a foreign</span>
      <span class="c1">// key value customer_id = 1...</span>
      <span class="c1">// As customer 1 is already in the persistence context</span>
      <span class="c1">// this same instance of customer 1 is used</span>
      <span class="n">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">Ebean</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">72</span><span class="o">);</span>
      <span class="n">Customer</span> <span class="n">customerB</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="na">getCustomer</span><span class="o">();</span>

      <span class="c1">// they are the same instance</span>
      <span class="n">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">customer</span> <span class="o">==</span> <span class="n">customerB</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
      <span class="n">Ebean</span><span class="o">.</span><span class="na">endTransaction</span><span class="o">();</span>
    <span class="o">}</span>
    
</pre></div>
</div>
  </p>

  <p>From these examples you should hopefully see that the persistence context acts as a
    cache to some degree. It can sometimes reduce the number of database queries required
    when you get object graphs and navigate them.</p>

  <p>However, the primary function of the persistence context is to ensure ... unique instances
    for a given identity (so that the object graphs are constructed in a consistent manor). The
    fact that it sometimes looks/acts like a cache is more of a side effect.</p>


  <h2>Query Scope</h2>
  <p>
    The purpose of the query scope is to effectively bypass a transaction scoped persistence context
    (l1 cache) in order to read fresh data from the database.
  </p>
  <p>
    The general scenario is that you are in the middle of a transaction and you want to make sure that
    a particular query hits the database to get fresh data. In doing so we want to avoid using the
    current transaction scoped persistence context.
  </p>



</div>

    </div>

    <div class="col-md-3" role="complementary">
      <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm">
        <ul class="nav bs-docs-sidenav">
<li >
  <a href="/docs/introduction">Introduction</a>
</li>
<li >
  <a href="/docs/enhancement">Enhancement</a>
</li>
<li >
  <a href="/docs/logging">Logging</a>
</li>
<li >
  <a href="/docs/serverconfig">ServerConfig</a>
</li>
<li >
  <a href="/docs/guice">Guice</a>
</li>
<li >
  <a href="/docs/spring">Spring</a>
</li>
<li >
  <a href="/docs/activerecord">Active Record</a>
</li>
<li >
  <a href="/docs/dbmigration">DB Migration</a>
</li>
<li >
  <a href="/docs/testing">Testing</a>
</li>
<li >
  <a href="/docs/query-overview">Query Overview</a>
</li>
<li >
  <a href="/docs/query-nplus1">Query N + 1</a>
</li>
<li >
  <a href="/docs/query-partialobjects">Query Partial Objects</a>
</li>
<li >
  <a href="/docs/query-autotune">Query Automatic Tuning</a>
</li>
<li >
  <a href="/docs/query-typesafe">Query Type Safety</a>
</li>
<li >
  <a href="/docs/queries">Queries</a>
</li>
<li >
  <a href="/docs/persisting">Persisting</a>
</li>
<li >
  <a href="/docs/mapping">Mapping</a>
</li>
<li >
  <a href="/docs/transactions">Transactions</a>
</li>
<li >
  <a href="/docs/json">JSON</a>
</li>
<li >
  <a href="/docs/eventlisteners">Event listeners</a>
</li>
<li >
  <a href="/docs/readauditing">Read Auditing</a>
</li>
<li >
  <a href="/docs/changelog">Change Log</a>
</li>
<li >
  <a href="/docs/history">History</a>
</li>
<li >
  <a href="/docs/l2caching">L2 caching</a>
</li>
<li >
  <a href="/docs/jvmlanguages">JVM Languages</a>
</li>

<li >
  <a href="/docs/clustering">Clustering</a>
</li>
<li >
  <a href="/docs/monitoring">Monitoring</a>
</li>
<li class="active">
  <a href="/docs/architecture/persistence-context">Architecture</a>
<ul class="nav">
  <li><a href="/docs/architecture/persistence-context">Persistence context</a></li>
  <li><a href="/docs/architecture/load-context">Load context</a></li>
  <li><a href="/docs/architecture/jdbc-batch-buffer">JDBC batch buffer</a></li>
  <li><a href="/docs/architecture/entity-enhancement">Entity Enhancement</a></li>
</ul>
</li>
        </ul>
      </nav>
    </div>
  </div>

</div>
<!-- /.row -->
</div>  <!-- /.container -->
  </div>
</div>

<footer id="footer">
 <div class="doc-footer">
  <ul class="doc-footer-links">
    <li><a href="/">Ebean ORM</a></li>
    <li> | </li>
    <li><a href="http://avaje-metric.github.io">Metrics</a></li>
    <li> | </li>
    <li><a href="/websitegenerator/index">Website Generator</a></li>
    <li> | </li>
    <li><a href="/jetty/index">Jetty Runnable War</a></li>
  </ul>
 </div>
</footer>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <script src="/js/jquery.easing.min.js"></script>

  <script src="/js/json2.js"></script>
  <script src="/js/jquery.cookie.min.js"></script>
  <script src="/js/jquery.storageapi.min.js"></script>

  <script src="/js/ebean-site.js"></script>

  </body>
</html>
