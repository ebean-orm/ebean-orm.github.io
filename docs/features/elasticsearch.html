
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta id="layout-head" />
    <title>Ebean ORM - Java/Kotlin/JVM</title>
    <link rel="shortcut icon" href="/images/favicon.ico" >
    <!--<link href="/css/bootstrap.min.css" rel="stylesheet">-->
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="/css/site.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">
      <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
  <body>
  <div id="wrap">
    <div id="header">
    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">Ebean ORM</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav pull-right">
            <li ><a href="/"><span class="glyphicon glyphicon-home"></span>  Home</a></li>
            <li ><a href="/videos">Videos</a></li>
            <li ><a href="/quickstart">Quick Start</a></li>
            <li ><a href="/support">Support</a></li>
            <li class="active"><a href="/docs">Docs</a></li>
            <li ><a target="_blank" href="/apidocs">ApiDocs</a></li>
            <li ><a href="/releases">Releases</a></li>
            <li ><a target="_blank" href="https://github.com/ebean-orm/avaje-ebeanorm"> <i class="fa fa-github"></i> Github</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

  </div>
  <div id="main" data-offset="60">
<div class="jumbotron mini">
  <div class="container">
    <h1><a href="/docs">Documentation</a> / <a href="/docs/features">Features</a> / ElasticSearch </h1>
  </div>
</div>

<div class="container doc-index bs-docs-container">

  <div class="row">

    <div class="col-md-9" role="main">
      <div class="bs-docs-section">
  <h2 id="overview">Overview</h2>
  <p>
    There are quite a few different reasons why ElasticSearch integration is useful to applications using
    Ebean ORM.
  </p>
  <h4>ElasticSearch value</h4>
  <ul>
    <li>Provides 'text search'</li>
    <li>Provides something like DB materialised views</li>
    <li>Scaling read access</li>
    <li>Read access performance (Document storage)</li>
    <li>Fixes an issue with L2 cache</li>
    <li>Provides L3 cache</li>
  </ul>

  <h4>Provides 'text search'</h4>
  <p>
    Many modern applications provide a single search input field to operate in a 'Google search' fashion.
    For example, searching for customers including their name and address (street, city, country etc).
  </p>
  <p>
    ElasticSearch uses analysers and inverted indexes to make "text search" fast and efficient.
    OLTP databases generally provide very different indexing via BTree and BitMap indexes which are orientated
    towards the needs of OLTP (short transactions, self balancing etc).
  </p>

  <h4>Provides something like DB materialised views</h4>
  <p>
    Many databases provide materialised views which are generally derived / calculated views used to provide
    faster views of the data. Materialised views are often refreshed periodically and used by applications
    knowing that the derived / calculated data is only refreshed periodically and potentially stale.
    For example, product pricing might be refreshed every midnight.
  </p>
  <p>
    ElasticSearch indexes can sometimes be thought in a similar way to DB materialised views. They represent
    a materialised (document orientated) view of the data which can be updated in near real time with each commit
    or updated in a more periodic batch fashion.
  </p>

  <h4>Scaling read access</h4>
  <p>
    ElasticSearch has built in horizontal scaling and this can be used to provide an easier / cheaper way to
    scale read access when compared to scaling a more traditional OLTP database. Note that the access is not
    equivalent to that provided by most OLTP databases (does not provide the same transactional read consistency
    guarantees and is 'near' real time but usually lags by a second etc) - however, these limitations are often
    acceptable given the improved read scalability.
  </p>

  <h4>Read access performance (denormalised document storage)</h4>
  <p>
    ElasticSearch can also be viewed as a document store and often the 'documents' stored are denormalised and
    contain derived and joined information. This means a retrieve of a single document in elastic search can
    compete with a SQL query would involve many joins. For example, an Order document might be denormalised and
    otherwise in a SQL query join Order, OrderDetails, Customer and Product tables.
  </p>
  <p>
    The traditional downsides of denormalised data exist but when your OLTP database is still the primary
    data store and ElasticSearch is a secondary store then storing 'denormalised documents' is nicely manageable.
  </p>


  <h4>Fixes an issue with L2 cache</h4>
  <p>
    Ebean like other ORM's has an L2 cache and specifically all face the issue specifically with the
    <code>L2 Query cache</code> being invalidated frequently.
  </p>
  <p>
    Essentially if an application is reliant on the <code>L2 Query cache</code> on a bean type that is
    frequently changed (Inserts, updates or deletes) then this will result in load on the database
    (ineffective utilisation of the L2 Query cache as it is frequently invalidated).
  </p>
  <p>
    ElasticSearch provides many relational predicates and many "relational" queries can be reasonably
    executed against ElasticSearch. If there is a need to scale "findMany" queries against frequently
    updated tables then ElasticSearch can provide a good solution (and a ORM L2 query cache faces
    significant limitations in this case).
  </p>


  <h4>Provides L3 cache</h4>
  <p>
    Ebean can use ElasticSearch as an L3 cache (you can think of it as the remote part of an L2 cache).
    If there is a miss in the local L2 cache Ebean can go and hit ElasticSearch rather than the database
    with the benefits that ElasticSearch is known to have all the data and have it in denormalised form
    (so a single hit against ElasticSearch might populate more of the graph than a traditional DB hit).
  </p>



  <h2 id="mapping">Mapping</h2>

  <h4><code>@DocStore</code></h4>
  <p>
    TODO
  </p>
<div class="syntax java"><div class="highlight"><pre>  <span class="c1">// Store contact in ElasticSearch using default setup</span>
  <span class="nd">@DocStore</span>
  <span class="nd">@Entity</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Contact</span> <span class="o">{</span>
</pre></div>
</div>

  <h4><code>@DocStoreEmbedded</code></h4>
  <p>
    On @ManyToOne and @OneToMany properties you can specify the properties that should be
    included in the document that is to be indexed.

  </p>
<div class="syntax java"><div class="highlight"><pre>  <span class="nd">@DocStore</span>
  <span class="nd">@Entity</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Contact</span> <span class="o">{</span>

    <span class="o">...</span>
    <span class="c1">// denormalise including the customer id and name</span>
    <span class="c1">// into the &#39;contact&#39; document</span>
    <span class="nd">@DocStoreEmbedded</span><span class="o">(</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;id,name&quot;</span><span class="o">)</span>
    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">optional</span><span class="o">=</span><span class="kc">false</span><span class="o">)</span>
    <span class="n">Customer</span> <span class="n">customer</span><span class="o">;</span>
</pre></div>
</div>

  <h2>DocumentStore</h2>
  <p>

  </p>
  <div class="syntax java"><div class="highlight"><pre>  <span class="n">DocumentStore</span> <span class="n">docStore</span> <span class="o">=</span> <span class="n">Ebean</span><span class="o">.</span><span class="na">getDefaultServer</span><span class="o">().</span><span class="na">docStore</span><span class="o">()</span>

  <span class="n">docStore</span><span class="o">.</span><span class="na">indexByQuery</span><span class="o">(</span><span class="n">query</span><span class="o">);</span>
  <span class="n">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">docStore</span><span class="o">.</span><span class="na">getById</span><span class="o">(</span><span class="n">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>

  
</pre></div>
</div>


  <h2>Index by Query</h2>
<div class="syntax java"><div class="highlight"><pre>  <span class="n">Query</span><span class="o">&lt;</span><span class="n">Order</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">Ebean</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">Order</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">where</span><span class="o">().</span><span class="na">gt</span><span class="o">(</span><span class="s">&quot;id&quot;</span><span class="o">,</span> <span class="mi">1</span><span class="o">).</span><span class="na">query</span><span class="o">();</span>

  <span class="n">Ebean</span><span class="o">.</span><span class="na">getDefaultServer</span><span class="o">().</span><span class="na">docStore</span><span class="o">().</span><span class="na">indexByQuery</span><span class="o">(</span><span class="n">query</span><span class="o">);</span>
</pre></div>
</div>


<div class="syntax java"><div class="highlight"><pre> <span class="cm">/**</span>
<span class="cm">  * Document storage operations.</span>
<span class="cm">  */</span>
 <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">DocumentStore</span> <span class="o">{</span>

 <span class="cm">/**</span>
<span class="cm">  * Update the associated document store using the result of the query.</span>
<span class="cm">  * &lt;p&gt;</span>
<span class="cm">  * Note that the select and fetch paths of the query is set for you to match the</span>
<span class="cm">  * document structure needed for the index so what this query requires is the</span>
<span class="cm">  * predicates only.</span>
<span class="cm">  * &lt;/p&gt;</span>
<span class="cm">  * &lt;p&gt;</span>
<span class="cm">  *   This query will be executed using findEach so it is safe to use a query</span>
<span class="cm">  *   that will fetch a lot of beans. The default bulkBatchSize is used.</span>
<span class="cm">  * &lt;/p&gt;</span>
<span class="cm">  *</span>
<span class="cm">  * @param query The query used to update the associated document store.</span>
<span class="cm">  */</span>
 <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">indexByQuery</span><span class="o">(</span><span class="n">Query</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">query</span><span class="o">);</span>

 <span class="cm">/**</span>
<span class="cm">  * Update the associated ElasticSearch index using the result of the query additionally specifying a</span>
<span class="cm">  * bulkBatchSize to use for sending the messages to ElasticSearch.</span>
<span class="cm">  */</span>
 <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">indexByQuery</span><span class="o">(</span><span class="n">Query</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">query</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bulkBatchSize</span><span class="o">);</span>

 <span class="cm">/**</span>
<span class="cm">  * Return the bean by fetching it&#39;s content from the document store.</span>
<span class="cm">  */</span>
 <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">getById</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">beanType</span><span class="o">,</span> <span class="n">Object</span> <span class="n">id</span><span class="o">);</span>

 <span class="o">}</span>
</pre></div>
</div>

</div>
    </div>

    <div class="col-md-3" role="complementary">
      <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm">
        <ul class="nav bs-docs-sidenav">


<li >
  <a href="/docs/features/json">JSON</a>
</li>
<li >
  <a href="/docs/features/json-in-db">JSON in DB</a>
</li>
<li >
  <a href="/docs/features/eventlistening">Event listening</a>
</li>

<li >
  <a href="/docs/features/softdelete">Soft Delete</a>
</li>

<li >
  <a href="/docs/features/who">Who Created Modified</a>
</li>

<li >
  <a href="/docs/features/readauditing">Read Auditing</a>
</li>
<li >
  <a href="/docs/features/changelog">Change Log</a>
</li>
<li >
  <a href="/docs/features/history">History SQL2011</a>
</li>
<li >
  <a href="/docs/features/draftable">Draftable</a>
</li>
<li >
  <a href="/docs/features/l2caching">L2 caching</a>
</li>

<li class="active">
  <a href="/docs/features/elasticsearch">ElasticSearch</a>
<ul class="nav">
  <li><a href="#overview">Overview</a></li>
  <li><a href="#mapping">Mapping</a></li>
</ul>
</li>

<li >
  <a href="/docs/features/jvmlanguages">JVM Languages</a>
</li>

<li >
  <a href="/docs/features/clustering">Clustering</a>
</li>
<li >
  <a href="/docs/features/monitoring">Monitoring</a>
</li>
<li >
  <a href="/docs/setup/dbmigration">DB Migration</a>
</li>
        </ul>
      </nav>
    </div>
  </div>

</div>
<!-- /.row -->
</div>  <!-- /.container -->
  </div>
</div>

<footer id="footer">
 <div class="doc-footer">
  <ul class="doc-footer-links">
    <li><a href="/">Ebean ORM</a></li>
    <li> | </li>
    <li><a href="http://avaje-metric.github.io">Metrics</a></li>
    <li> | </li>
    <li><a href="/websitegenerator/index">Website Generator</a></li>
    <li> | </li>
    <li><a href="/jetty/index">Jetty Runnable War</a></li>
  </ul>
 </div>
</footer>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <script src="/js/jquery.easing.min.js"></script>

  <script src="/js/json2.js"></script>
  <script src="/js/jquery.cookie.min.js"></script>
  <script src="/js/jquery.storageapi.min.js"></script>

  <script src="/js/ebean-site.js"></script>

  </body>
</html>
